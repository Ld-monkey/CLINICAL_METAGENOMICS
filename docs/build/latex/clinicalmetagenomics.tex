%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,french]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{CLINICAL METAGENOMICS}
\date{juil. 21, 2020}
\release{0.0.1}
\author{Zygnematophyce}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Version}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


Current version: 1.0.0 Juillet 2020
\begin{quote}\begin{description}
\item[{Python version}] \leavevmode
Python 3.7

\item[{Source}] \leavevmode
\sphinxurl{https://github.com/Zygnematophyce/CLINICAL\_METAGENOMICS}.

\end{description}\end{quote}


\chapter{Qu’est ce que le projet CLINICAL METAGENOMICS ?}
\label{\detokenize{index:qu-est-ce-que-le-projet-clinical-metagenomics}}
\sphinxstylestrong{CLINICAL METAGENOMICS} est un ensemble de programme de bio\sphinxhyphen{}informatique adaptés à la dectection des pathogènes dans un échantillon clinique de métagénomique.

Il permet :
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Le téléchargement des librairies de séquences.

\item {} 
La création et l’indexation des bases de données de références pour la métagénomique.

\item {} 
L’analyse des résultats NGS.

\end{enumerate}

Actuellement, …


\chapter{Guide d’utilisation et référence}
\label{\detokenize{index:guide-d-utilisation-et-reference}}

\section{Installation}
\label{\detokenize{installation_conda_environnement:installation}}\label{\detokenize{installation_conda_environnement::doc}}
L’installation du projet est facilité par l’utilisation de Conda.

Conda est un gestionnaire de paquets, il permet de créer son propre environnement virtuel contenant les logiciels informatiques nécessaires au fonctionnement du pipeline de métagénomique (exemple Kraken 2, la suite blast\sphinxhyphen{}plus etc…). Pour créer un environnement conda à partir du fichier yaml (metagenomic\_env.yml) :


\subsection{Télécharger le projet sur github}
\label{\detokenize{installation_conda_environnement:telecharger-le-projet-sur-github}}
Télécharger le projet

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git clone https://github.com/Zygnematophyce/CLINICAL\PYGZus{}METAGENOMICS.git
\end{sphinxVerbatim}


\subsection{Création de l’environnement conda}
\label{\detokenize{installation_conda_environnement:creation-de-l-environnement-conda}}
Pour créer un environnement conda à partir du fichier yaml (metagenomic\_env.yml) :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
conda env create \PYGZhy{}f metagenomic\PYGZus{}env.yml
\end{sphinxVerbatim}

Pour supprimer définitivement l’environnement :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
conda env remove \PYGZhy{}n metagenomic\PYGZus{}env
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
De manière générale, une fois l’environnement conda installé on ne le supprime pas à chaque fois. La dernière ligne de commande est à titre d’information dans le cas ou vous voulez supprimer définitivement l’environnement conda.
\end{sphinxadmonition}


\subsection{Activation de l’environnement conda}
\label{\detokenize{installation_conda_environnement:activation-de-l-environnement-conda}}
Pour activer l’environnement conda :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
conda active metagenomic\PYGZus{}env
\end{sphinxVerbatim}

Pour désactiver l’environnement conda :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
conda deactivate
\end{sphinxVerbatim}


\subsection{Les messages d’erreurs}
\label{\detokenize{installation_conda_environnement:les-messages-d-erreurs}}
Dans certains cas, des messages d’erreurs peuvent survenir.

\begin{sphinxadmonition}{warning}{Avertissement:}
CommandNotFoundError: Your shell has not been properly configured to use “conda activate”.
To initialize your shell, run
\$ conda init \textless{}SHELL\_NAME\textgreater{}
\end{sphinxadmonition}

Dans ce cas et pour les distributions Linux, exécuter la commande suivante dans un terminal.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{echo} \PYGZhy{}e \PYG{l+s+s2}{\PYGZdq{}export \PYGZhy{}f conda\PYGZbs{}nexport \PYGZhy{}f \PYGZus{}\PYGZus{}conda\PYGZus{}activate\PYGZbs{}nexport \PYGZhy{}f \PYGZus{}\PYGZus{}conda\PYGZus{}reactivate\PYGZbs{}nexport \PYGZhy{}f \PYGZus{}\PYGZus{}conda\PYGZus{}hashr\PYGZbs{}nexport \PYGZhy{}f \PYGZus{}\PYGZus{}add\PYGZus{}sys\PYGZus{}prefix\PYGZus{}to\PYGZus{}path\PYGZdq{}} \PYGZgt{}\PYGZgt{} \PYGZti{}/.bashrc
\end{sphinxVerbatim}

Ensuite ouvrir un nouveau terminal.


\section{Vue d’ensemble}
\label{\detokenize{overview:vue-d-ensemble}}\label{\detokenize{overview::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{flowchart_pipeline_metagenomic}.png}\hspace*{\fill}}

Simple organigramme des étapes de métagénomique clinique (image par Zygnematophyce)


\subsection{Étape de pré\sphinxhyphen{}traitement}
\label{\detokenize{overview:etape-de-pre-traitement}}
L’étape de pré\sphinxhyphen{}traitement (ou pre\sphinxhyphen{}processing en anglais) est nécessaire avant toute analyse. Cette étape consiste à éliminer les séquences de mauvaise qualité et les séquences dupliquées à partir des fichiers fastq de reads bruts (raw reads sequences) issus du séquençage. Cette étape permet de réduire la quantité d’informations à traiter, et d’éliminer les informations redondantes. Vous pouvez utiliser le programme construit à cette occasion dans la session {\hyperref[\detokenize{tutorial:pre-processing}]{\sphinxcrossref{\DUrole{std,std-ref}{le pré\sphinxhyphen{}traitement des reads}}}} du tutoriel.


\subsection{Création des bases de données de références}
\label{\detokenize{overview:creation-des-bases-de-donnees-de-references}}
Avant de classifier les reads, il est indispensable de créer des bases de données de référence pour identifier un organisme. Au total, 4 bases de données ont été créées :


\subsubsection{La base de données FDA\sphinxhyphen{}ARGOS}
\label{\detokenize{overview:la-base-de-donnees-fda-argos}}
FDA\sphinxhyphen{}ARGOS est une base de données génomique, curée, et publique. Cette base de
données est construite à des fins de diagnostic clinique. FDA\sphinxhyphen{}ARGOS applique des mesures de qualité sur les séquences de pathogènes qui la composent. Ces mesures de qualité sont basées par exemple sur des critères tels que l’assemblage du génome avec une couverture de 95\% couplé à d’autres critères.

Au final la base de données FDA\sphinxhyphen{}ARGOS est composée à la date de décembre 2019 de 487 isolats avec 88,3\% de bactéries, 11,1\% des virus et 0,6\% d’eucaryotes, représentant 189 taxons différents avec au total 81,9\% des génomes d’origine clinique et les 8,1\% restants de génomes environnementaux.

Pour télécharger la base de données FDA\sphinxhyphen{}ARGOS utiliser le programme construit décrit dans la session {\hyperref[\detokenize{tutorial:download-fda-argos}]{\sphinxcrossref{\DUrole{std,std-ref}{Le téléchargement de la base de données FDA\sphinxhyphen{}ARGOS}}}} du tutoriel.


\subsubsection{La base de données Mycocosm}
\label{\detokenize{overview:la-base-de-donnees-mycocosm}}
La base de données Mycocosm est un projet de génomique fongique du Joint Genome Institute (JGI) qui s’est associé à la communauté scientifique internationale pour soutenir l’exploration génomique des champignons.

Aujourd’hui le portail propose plus de 1000 espèces fongiques et plus de 500 familles fongiques.

Pour télécharger la base de données de Mycocosm utiliser le programme construit décrit dans la session {\hyperref[\detokenize{tutorial:download-mycocosm}]{\sphinxcrossref{\DUrole{std,std-ref}{Le téléchargement de la base de données Mycocosm}}}} du tutoriel.


\subsubsection{La base de données FungiDB}
\label{\detokenize{overview:la-base-de-donnees-fungidb}}
FungiDB (fungidb.org) est une ressource en ligne gratuite pour l’exploration de données et l’analyse génomique fonctionnelle des espèces fongiques et oomycètes. FungiDB contient un nombre croissant de génomes de divers taxons, y compris des plantes, des animaux et des pathogènes humains.

Pour télécharger la base de données de FungiDB utiliser le programme construit décrit dans la session {\hyperref[\detokenize{tutorial:download-fungidb}]{\sphinxcrossref{\DUrole{std,std-ref}{Le téléchargement de la base de données FungiDB}}}} du tutoriel.


\subsubsection{La base de données RefSeq}
\label{\detokenize{overview:la-base-de-donnees-refseq}}
La base de données RefSeq comprend plus de 220 000 organismes (Jul, 2020) avec des genomes viraux et bactériens.
\begin{itemize}
\item {} 
Pour les virus, la base de données « viral » de RefSeq a été choisie : elle est composée des génomes complets d’environ 10 000 espèces virales (Jul 06, 2020) et apparait adaptée pour couvrir la grande majorité des virus rencontrés dans un échantillon clinique.

\item {} 
Pour les bactéries, l’utilisation d’une base de données de génomes complets comme « bacteria » de RefSeq est composée de 62 000 espèces bactériennes (Jul 06, 2020).

\end{itemize}

Pour télécharger la base de données de RefSeq utiliser le programme construit décrit dans la session {\hyperref[\detokenize{tutorial:download-refseq}]{\sphinxcrossref{\DUrole{std,std-ref}{Le téléchargement de la base de données RefSeq}}}} du tutoriel.

\begin{sphinxadmonition}{note}{Note:}
Les chiffres officiels pour chaque taxon sont visibles sur le lien suivant : \sphinxurl{ftp://ftp.ncbi.nlm.nih.gov/refseq/release/release-statistics/} .
\end{sphinxadmonition}


\subsection{Étape de classification}
\label{\detokenize{overview:etape-de-classification}}
La classification taxonomique est une étape cruciale de la métagénomique. Plusieurs algorithmes et outils permettent d’identifier les organismes. L’outil le plus connu est sans doute l’algorithme de BLAST. Cependant, BLAST est un outil qui demande beaucoup de ressource, et prend du temps d’exécution lorsqu’il s’agit de comparer un read à l’ensemble d’une base de données. Pour identifier plus rapidement les reads, une solution alternative est proposé par l’outil Kraken 2 qui utilise l’algorithme des k\sphinxhyphen{}mers. L’algorithme de k\sphinxhyphen{}mer va hacher les reads et les séquences dans les bases de données en fragment de nucléotide. Avant d’identifier un organisme, Kraken 2 va indexer la base de données en associant un identifiant taxonomique aux k\sphinxhyphen{}mer d’une base de données. Enfin pour classifier des reads, Kraken 2 compare l’association exacte des k\sphinxhyphen{}mers d’un read à ceux d’une base de données et détermine l’identifiant taxonomique associé.

Pour indexer une bases de données avec l’algorithme de k\sphinxhyphen{}mer utiliser le programme décrit dans la session {\hyperref[\detokenize{tutorial:indexation-kraken2}]{\sphinxcrossref{\DUrole{std,std-ref}{L’indexation d’une base de données avec Kraken 2}}}} du tutoriel.

Pour classifier un échantillon de reads par rapport à une base de données utiliser le programme décrit dans la session {\hyperref[\detokenize{tutorial:classification-kraken2}]{\sphinxcrossref{\DUrole{std,std-ref}{Classification des reads avec Kraken 2}}}} du tutoriel.


\subsection{Étape d’analyse des résultats}
\label{\detokenize{overview:etape-d-analyse-des-resultats}}

\section{Tutoriel}
\label{\detokenize{tutorial:tutoriel}}\label{\detokenize{tutorial::doc}}
Ci\sphinxhyphen{}dessous vous pouvez trouver le tutoriel sur comment utiliser le pipeline de métagénomique clinique.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Sommaire}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{tutorial:id37}}{\hyperref[\detokenize{tutorial:tutoriel}]{\sphinxcrossref{Tutoriel}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{tutorial:id38}}{\hyperref[\detokenize{tutorial:le-pre-traitement-des-reads}]{\sphinxcrossref{Le pré\sphinxhyphen{}traitement des reads}}}

\item {} 
\phantomsection\label{\detokenize{tutorial:id39}}{\hyperref[\detokenize{tutorial:le-telechargement-de-la-base-de-donnees-fda-argos}]{\sphinxcrossref{Le téléchargement de la base de données FDA\sphinxhyphen{}ARGOS}}}

\item {} 
\phantomsection\label{\detokenize{tutorial:id40}}{\hyperref[\detokenize{tutorial:le-telechargement-de-la-base-de-donnees-mycocosm}]{\sphinxcrossref{Le téléchargement de la base de données Mycocosm}}}

\item {} 
\phantomsection\label{\detokenize{tutorial:id41}}{\hyperref[\detokenize{tutorial:le-telechargement-de-la-base-de-donnees-fungidb}]{\sphinxcrossref{Le téléchargement de la base de données FungiDB}}}

\item {} 
\phantomsection\label{\detokenize{tutorial:id42}}{\hyperref[\detokenize{tutorial:le-telechargement-de-la-base-de-donnees-refseq}]{\sphinxcrossref{Le téléchargement de la base de données RefSeq}}}

\item {} 
\phantomsection\label{\detokenize{tutorial:id43}}{\hyperref[\detokenize{tutorial:l-indexation-d-une-base-de-donnees-avec-kraken-2}]{\sphinxcrossref{L’indexation d’une base de données avec Kraken 2}}}

\item {} 
\phantomsection\label{\detokenize{tutorial:id44}}{\hyperref[\detokenize{tutorial:classification-des-reads-avec-kraken-2}]{\sphinxcrossref{Classification des reads avec Kraken 2}}}

\item {} 
\phantomsection\label{\detokenize{tutorial:id45}}{\hyperref[\detokenize{tutorial:creation-d-une-base-de-donnees-avec-la-suite-blast}]{\sphinxcrossref{Création d’une base de données avec la suite BLAST+}}}

\item {} 
\phantomsection\label{\detokenize{tutorial:id46}}{\hyperref[\detokenize{tutorial:classification-des-reads-avec-la-suite-blast}]{\sphinxcrossref{Classification des reads avec la suite BLAST+}}}

\end{itemize}

\end{itemize}
\end{sphinxShadowBox}
\phantomsection\label{\detokenize{tutorial:pre-processing}}
\begin{sphinxadmonition}{warning}{Avertissement:}
Dans la majorité des programmes présentés dans les sessions suivantes, il est possible de consulter les paramètres précis d’un programme en ajoutant la comme \sphinxhyphen{}h pour help comme illustré ci\sphinxhyphen{}contre.
\end{sphinxadmonition}

Pour appeler l’aide dans les programmes :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{programme}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZhy{}}\PYG{n}{h}
\end{sphinxVerbatim}


\subsection{Le pré\sphinxhyphen{}traitement des reads}
\label{\detokenize{tutorial:le-pre-traitement-des-reads}}
L’exemple suivant nous montre comment utiliser les étapes de pré\sphinxhyphen{}traitement.


\subsubsection{Programme}
\label{\detokenize{tutorial:programme}}
Nom du programme:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{remove\PYGZus{}poor\PYGZus{}quality\PYGZus{}duplicate\PYGZus{}reads\PYGZus{}preprocess}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}


\subsubsection{Localisation}
\label{\detokenize{tutorial:localisation}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
└── src
 ├── bash
 │   ├── remove\PYGZus{}poor\PYGZus{}quality\PYGZus{}duplicate\PYGZus{}reads\PYGZus{}preprocess.sh
\end{sphinxVerbatim}


\subsubsection{Les outils utilisés}
\label{\detokenize{tutorial:les-outils-utilises}}\begin{quote}\begin{description}
\item[{Clumpify.sh}] \leavevmode
Le script Clumpify.sh de l’aligneur BBMap permet d’identifier les séquences identiques en sortie de séquençage. Configuré avec le paramètre Dedupe le script clumpify, fait intervenir le logiciel Dedupe de la suite BBMap pour éliminer les reads dupliqués.

\item[{Dedupe}] \leavevmode
Dedupe supprime les reads dupliqués.

\item[{Trimmomatic}] \leavevmode
Trimmomatic permet de supprimer les reads de mauvaises qualités c’est à dire les reads qui ont un score phread (score de qualité) moyen d’au moins 20 et des reads de taille minimum de 50 nucléotides pour avoir assez d’information pour classifier les reads.

\end{description}\end{quote}


\subsubsection{Exemple d’utilisation}
\label{\detokenize{tutorial:exemple-d-utilisation}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash src/bash/remove\PYGZus{}poor\PYGZus{}quality\PYGZus{}duplicate\PYGZus{}reads\PYGZus{}preprocess.sh \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}path\PYGZus{}reads data/reads/PAIRED\PYGZus{}SAMPLES\PYGZus{}ADN\PYGZus{}TEST/ \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}path\PYGZus{}output results/trimmed\PYGZus{}reads/trimmed\PYGZus{}PAIRED\PYGZus{}SAMPLES\PYGZus{}ADN\PYGZus{}TEST\PYGZus{}reads\PYGZus{}04\PYGZus{}06\PYGZus{}2020/ \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}threads \PYG{l+m}{28}
\end{sphinxVerbatim}

Dans cet exemple, nous indiquons le dossier contenant les reads et nous précisons le dossier de sortie pour lequel les reads sortirons traités et filtrés. Nous pouvons préciser le nombre de threads pour accélérer le traitement, ici le nombre de thread est à 28.


\subsubsection{Les paramètres}
\label{\detokenize{tutorial:les-parametres}}\begin{quote}\begin{description}
\item[{\sphinxhyphen{}path\_reads}] \leavevmode
(Input) Le chemin du dossier avec l’ensemble des reads.

\item[{\sphinxhyphen{}path\_outputs}] \leavevmode
(Output) Le chemin du dossier de sortie des reads pré\sphinxhyphen{}traités.

\item[{\sphinxhyphen{}threads}] \leavevmode
(Input) Le nombre de thread (par défaut configuré à 1 thread).

\item[{\sphinxhyphen{}force\_remove}] \leavevmode
(Optionnel) Par défaut la valeur est sur « yes » et permet de supprimer les fichiers intermédiaires. Pour ne pas supprimer les fichiers intermédiaires configurer le paramètre avec la valeur « no » comme avec l’exemple ci\sphinxhyphen{}contre :

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash src/bash/remove\PYGZus{}poor\PYGZus{}quality\PYGZus{}duplicate\PYGZus{}reads\PYGZus{}preprocess.sh \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}path\PYGZus{}reads data/reads/PAIRED\PYGZus{}SAMPLES\PYGZus{}ADN\PYGZus{}TEST/ \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}path\PYGZus{}output results/trimmed\PYGZus{}reads/trimmed\PYGZus{}PAIRED\PYGZus{}SAMPLES\PYGZus{}ADN\PYGZus{}TEST\PYGZus{}reads\PYGZus{}04\PYGZus{}06\PYGZus{}2020/ \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}force\PYGZus{}remove no \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}threads \PYG{l+m}{28}
\end{sphinxVerbatim}


\subsubsection{Les fichiers de sorties}
\label{\detokenize{tutorial:les-fichiers-de-sorties}}\begin{itemize}
\item {} 
Avec l’outil Trimmomatic :

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{name\PYGZus{}of\PYGZus{}read}\PYG{o}{\PYGZgt{}}\PYG{n}{\PYGZus{}trimmed}\PYG{o}{.}\PYG{n}{fastq}\PYG{o}{.}\PYG{n}{gz}
\end{sphinxVerbatim}

\sphinxstylestrong{\textless{}name\_of\_read\textgreater{}\_trimmed.fastq.gz} correspondent aux reads qui ont correctement répondu aux conditions de filtrage.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{name\PYGZus{}of\PYGZus{}read}\PYG{o}{\PYGZgt{}}\PYG{n}{\PYGZus{}unpair\PYGZus{}trimmed\PYGZus{}fastq}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxstylestrong{\textless{}name\_of\_read\textgreater{}\_unpair\_trimmed\_fastq.gz} correspondent aux reads qui n’ont pas correctement répondu aux conditions de filtrage.
\begin{itemize}
\item {} 
Avec l’outil Clumpify.sh et Dedupe:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{name\PYGZus{}of\PYGZus{}read}\PYG{o}{\PYGZgt{}}\PYG{n}{\PYGZus{}depupe}\PYG{o}{.}\PYG{n}{fastq} \PYG{p}{:}
\end{sphinxVerbatim}

\sphinxstylestrong{\textless{}name\_of\_read\textgreater{}\_depupe.fastq} est le résultat des outils Clumpify.sh et Dedupe pour les reads.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{name\PYGZus{}of\PYGZus{}read}\PYG{o}{\PYGZgt{}}\PYG{n}{\PYGZus{}info}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

\sphinxstylestrong{\textless{}name\_of\_read\textgreater{}\_info.txt} contient le nombre de reads totaux.


\subsection{Le téléchargement de la base de données FDA\sphinxhyphen{}ARGOS}
\label{\detokenize{tutorial:le-telechargement-de-la-base-de-donnees-fda-argos}}\label{\detokenize{tutorial:download-fda-argos}}
La session suivante, nous montre comment télécharger la base de données FDA\sphinxhyphen{}ARGOS.


\subsubsection{Programme}
\label{\detokenize{tutorial:id1}}
Nom du programme:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{download\PYGZus{}fda\PYGZus{}argos\PYGZus{}assembly}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}


\subsubsection{Localisation}
\label{\detokenize{tutorial:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
└── src
 ├── download
 │   ├── download\PYGZus{}fda\PYGZus{}argos\PYGZus{}assembly.sh
\end{sphinxVerbatim}


\subsubsection{Exemple d’utilisation}
\label{\detokenize{tutorial:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash src/download/download\PYGZus{}fda\PYGZus{}argos\PYGZus{}assembly.sh \PYG{l+s+se}{\PYGZbs{}}
                 \PYGZhy{}assembly\PYGZus{}xml data/assembly/assembly\PYGZus{}fda\PYGZus{}argos\PYGZus{}ncbi\PYGZus{}result.xml \PYG{l+s+se}{\PYGZbs{}}
                 \PYGZhy{}path\PYGZus{}output data/raw\PYGZus{}sequences/fda\PYGZus{}argos\PYGZus{}assembly\PYGZus{}raw\PYGZus{}sequences/
\end{sphinxVerbatim}

Dans cet exemple, nous téléchargeons les séquences assemblées de FDA\sphinxhyphen{}ARGOS à l’aide d’un fichier XML présent dans le dossier data/assembly/assembly\_fda\_argos\_ncbi\_result.xml de l’architecture du projet git et nous précisons le dossier de sortie qui contiendra toutes les séquences, ici nous voulons que les résultats se retrouvent dans le dossier data/raw\_sequences/fda\_argos\_assembly\_raw\_sequences/ .

\begin{sphinxadmonition}{note}{Note:}
Il serait intéressant d’ajouter une fonctionnalité au programme afin de télécharger le fichier XML automatiquement avec les requêtes de NCBI et ainsi avoir les dernières modifications et ajouts de la base de données FDA\sphinxhyphen{}ARGOS.
\end{sphinxadmonition}


\subsubsection{Les paramètres}
\label{\detokenize{tutorial:id4}}\begin{quote}\begin{description}
\item[{\sphinxhyphen{}assembly\_xml}] \leavevmode
(Input) Récupère le fichier XML pour l’analyser.

\item[{\sphinxhyphen{}path\_output}] \leavevmode
(Output) Le chemin du dossier de sortie des les séquences de FDA\sphinxhyphen{}ARGOS.

\end{description}\end{quote}


\subsubsection{Les fichiers de sorties}
\label{\detokenize{tutorial:id5}}
L’ensemble des séquences assemblées de FDA\sphinxhyphen{}ARGOS vont être téléchargées exemple :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
├── GCF\PYGZus{}000626615.2\PYGZus{}ASM62661v3\PYGZus{}genomic.fna
├── GCF\PYGZus{}000783435.2\PYGZus{}ASM78343v2\PYGZus{}genomic.fna
├── GCF\PYGZus{}000783445.2\PYGZus{}ASM78344v2\PYGZus{}genomic.fna
├── GCF\PYGZus{}000783455.2\PYGZus{}ASM78345v2\PYGZus{}genomic.fna
├── GCF\PYGZus{}000783465.2\PYGZus{}ASM78346v2\PYGZus{}genomic.fna
├── ...
\end{sphinxVerbatim}


\subsection{Le téléchargement de la base de données Mycocosm}
\label{\detokenize{tutorial:le-telechargement-de-la-base-de-donnees-mycocosm}}\label{\detokenize{tutorial:download-mycocosm}}
La session suivante, nous montre comment télécharger la base de données Mycocosm.


\subsubsection{Programme}
\label{\detokenize{tutorial:id6}}
Nom du programme:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{download\PYGZus{}mycocosm\PYGZus{}scaffolds}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}


\subsubsection{Localisation}
\label{\detokenize{tutorial:id7}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
└── src
 ├── download
 │   ├── download\PYGZus{}mycocosm\PYGZus{}scaffolds.sh
\end{sphinxVerbatim}

Pour pouvoir télécharger les séquences de Mycocosm plusieurs étapes doivent être réalisées.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{(}{)}%
\item {} 
Créer un compte sur le site du JGI \sphinxstyleemphasis{Joint Genome Institure} \sphinxurl{https://contacts.jgi.doe.gov/registration/new}

\item {} 
Confirmer votre inscription par mail.

\item {} 
Exécuter le programme.

\end{enumerate}


\subsubsection{Exemple d’utilisation}
\label{\detokenize{tutorial:id8}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash src/download/download\PYGZus{}mycocosm\PYGZus{}scaffolds.sh \PYG{l+s+se}{\PYGZbs{}}
                  \PYGZhy{}username mail@a.com\PYG{l+s+se}{\PYGZbs{}}
                  \PYGZhy{}password azerty \PYG{l+s+se}{\PYGZbs{}}
                  \PYGZhy{}path\PYGZus{}output data/raw\PYGZus{}sequences/mycoccosm\PYGZus{}fungi\PYGZus{}ncbi\PYGZus{}scaffolds/
\end{sphinxVerbatim}

Dans cet exemple, nous téléchargeons les scaffolds de la base de données Mycocosm en indiquant notre adresse mail avec le mot de passe associé (l’adresse mail et le mot de passe sont donnés ici à titre d’exemple et ne sont pas utilisables). Nous indiquons ensuite le chemin de sortie avec le paramètre \sphinxhyphen{}path\_output, ici les scaffolds irons dans le dossier de sortie data/raw\_sequences/mycoccosm\_fungi\_ncbi\_scaffolds/ .


\subsubsection{Dépendances}
\label{\detokenize{tutorial:dependances}}
Le programme dépend de deux scripts Python :

Le premier script Python est :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{src}\PYG{o}{/}\PYG{n}{download}\PYG{o}{/}\PYG{n}{download\PYGZus{}scaffold\PYGZus{}mycocosm\PYGZus{}jgi}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

\sphinxstylestrong{download\_scaffold\_mycocosm\_jgi.py} va télécharger :
\begin{itemize}
\item {} 
le cookie,

\item {} 
le fichier xml,

\item {} 
les séquences scaffolds,

\item {} 
et créer un fichier récapitulatif en format csv \sphinxstyleemphasis{(Comma\sphinxhyphen{}separated values)}.

\end{itemize}

Le second script Python est :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{src}\PYG{o}{/}\PYG{n}{python}\PYG{o}{/}\PYG{n}{jgi\PYGZus{}id\PYGZus{}to\PYGZus{}ncbi\PYGZus{}id\PYGZus{}taxonomy}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

\sphinxstylestrong{jgi\_id\_to\_ncbi\_id\_taxonomy.py} associe les identifiants taxonomiques utilisés par JGI dans les scaffold et convertit en identifiant taxonomique du NCBI.

\begin{sphinxadmonition}{note}{Note:}
Cette conversion est nécessaire car elle permet l’indexation des bases de données avec le logiciel Kraken 2. Kraken 2 (utilisé dans la suite du tutoriel) utilise et la taxonomie de référence du NCBI et l’algorithme de k\sphinxhyphen{}mer pour classifier les reads rapidement (voir section ..)
\end{sphinxadmonition}


\subsection{Le téléchargement de la base de données FungiDB}
\label{\detokenize{tutorial:le-telechargement-de-la-base-de-donnees-fungidb}}\label{\detokenize{tutorial:download-fungidb}}
La session suivante, nous montre comment télécharger la base de données FungiDB.


\subsubsection{Programme}
\label{\detokenize{tutorial:id9}}
Nom du programme:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{download\PYGZus{}fungi\PYGZus{}database\PYGZus{}release\PYGZus{}3}\PYG{o}{.}\PYG{l+m+mf}{0.}\PYG{n}{sh}
\end{sphinxVerbatim}


\subsubsection{Localisation}
\label{\detokenize{tutorial:id10}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
└── src
 ├── download
 │   ├── download\PYGZus{}fungi\PYGZus{}database\PYGZus{}release\PYGZus{}3.0.sh
\end{sphinxVerbatim}


\subsubsection{Exemple d’utilisation}
\label{\detokenize{tutorial:id11}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash src/download/download\PYGZus{}fungi\PYGZus{}database\PYGZus{}release\PYGZus{}3.0.sh \PYG{l+s+se}{\PYGZbs{}}
                  \PYGZhy{}path\PYGZus{}output data/raw\PYGZus{}sequences/fungi\PYGZus{}db\PYGZus{}all\PYGZus{}genomes\PYGZus{}06\PYGZus{}07\PYGZus{}2020/
\end{sphinxVerbatim}

Dans cet exemple, nous téléchargeons la base de données FungiDB et nous précisons le dossier de sortie qui est data/raw\_sequences/fungi\_db\_all\_genomes\_06\_07\_2020/ .


\subsubsection{Les paramètres}
\label{\detokenize{tutorial:id12}}\begin{quote}\begin{description}
\item[{\sphinxhyphen{}path\_output}] \leavevmode
(Output) Le chemin du dossier de sortie des séquences de FungiDB.

\end{description}\end{quote}


\subsubsection{Les fichiers de sorties}
\label{\detokenize{tutorial:id13}}
L’ensemble des séquences de FungiDB vont être téléchargées exemple :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
├── FungiDB\PYGZhy{}3.0\PYGZus{}Aaculeatus\PYGZus{}ATCC16872\PYGZus{}Genome.fasta
├── FungiDB\PYGZhy{}3.0\PYGZus{}Acapsulatus\PYGZus{}G186AR\PYGZus{}Genome.fasta
├── FungiDB\PYGZhy{}3.0\PYGZus{}Acapsulatus\PYGZus{}NAm1\PYGZus{}Genome.fasta
├── FungiDB\PYGZhy{}3.0\PYGZus{}Acarbonarius\PYGZus{}ITEM5010\PYGZus{}Genome.fasta
├── FungiDB\PYGZhy{}3.0\PYGZus{}Aclavatus\PYGZus{}NRRL1\PYGZus{}Genome.fasta
├── ...
\end{sphinxVerbatim}


\subsection{Le téléchargement de la base de données RefSeq}
\label{\detokenize{tutorial:le-telechargement-de-la-base-de-donnees-refseq}}\label{\detokenize{tutorial:download-refseq}}
La session suivante, nous montre comment télécharger la base de données RefSeq.


\subsubsection{Programme}
\label{\detokenize{tutorial:id14}}
Nom du programme:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{download\PYGZus{}refseq\PYGZus{}sequences}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}


\subsubsection{Localisation}
\label{\detokenize{tutorial:id15}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
└── src
 ├── download
 │   ├── download\PYGZus{}refseq\PYGZus{}sequences.sh
\end{sphinxVerbatim}


\subsubsection{Exemple d’utilisation}
\label{\detokenize{tutorial:id16}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash src/download/download\PYGZus{}refseq\PYGZus{}sequences.sh \PYG{l+s+se}{\PYGZbs{}}
     \PYGZhy{}type\PYGZus{}db viral \PYG{l+s+se}{\PYGZbs{}}
     \PYGZhy{}type\PYGZus{}sq genomic \PYG{l+s+se}{\PYGZbs{}}
     \PYGZhy{}path\PYGZus{}output data/raw\PYGZus{}sequences/refseq\PYGZus{}viral/
\end{sphinxVerbatim}

Dans cet exemple, nous téléchargeons les séquences virales de la base de données RefSeq en précisant le type de la base de données qui est donc \sphinxhyphen{}type\_db viral et quel type de séquence nous voulons entre le génome et ou les protéines, ici nous choisissons le génome en indiquant \sphinxhyphen{}type\_sq genomic. Les différentes séquences téléchargées iront dans le dossier de sortie data/raw\_sequences/refseq\_viral/.


\subsubsection{Les paramètres}
\label{\detokenize{tutorial:id17}}\begin{quote}\begin{description}
\item[{\sphinxhyphen{}type\_db}] \leavevmode
(Input) Quel type de librairie à télécharger.

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
La liste de tous les organismes que l’on peut télécharger avec le programme ci\sphinxhyphen{}dessus :
\begin{itemize}
\item {} 
bacteria

\item {} 
viral

\item {} 
archaea

\item {} 
fungi

\item {} 
invertebrate

\item {} 
mitochondrion

\item {} 
plant

\item {} 
plasmid

\item {} 
plastid

\item {} 
protozoa

\item {} 
vertebrate\_mammalian

\item {} 
human

\end{itemize}
\end{sphinxadmonition}

Avec le programme, nous pouvons télécharger plusieurs librairies à la fois mais il faut ajouter des guillemets pour indiquer que l’on veut ajouter plusieurs paramètres comme illustré dans l’exemple suivant :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash src/download/download\PYGZus{}refseq\PYGZus{}sequences.sh \PYG{l+s+se}{\PYGZbs{}}
        \PYGZhy{}type\PYGZus{}db \PYG{l+s+s2}{\PYGZdq{}viral bacteria\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{}}
        \PYGZhy{}type\PYGZus{}sq \PYG{l+s+s2}{\PYGZdq{}genomic protein\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{}}
        \PYGZhy{}path\PYGZus{}output data/raw\PYGZus{}sequences/refseq\PYGZus{}viral\PYGZus{}bacteria\PYGZus{}genomics\PYGZus{}proteins/
\end{sphinxVerbatim}

Dans cet exemple, nous téléchargeons les séquences génomiques et protéiques des virus et bactéries de la base de données RefSeq.
\begin{quote}\begin{description}
\item[{\sphinxhyphen{}type\_sq}] \leavevmode
(Optionel) Précise le type de séquence à télécharger. Le choix se limite aux protéines (protein) et ou génomes (genomic). Par défaut, c’est le génome qui est téléchargé si cet argument n’est pas précisé.

\item[{\sphinxhyphen{}path\_output}] \leavevmode
(Output) Le chemin du dossier de sortie des séquences de RefSeq.

\end{description}\end{quote}


\subsubsection{Les fichiers de sorties}
\label{\detokenize{tutorial:id18}}
L’ensemble des séquences de RefSeq vont être téléchargées exemple :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
.
├── viral.1.1.genomic.fna.gz
└── viral.2.1.genomic.fna.gz
\end{sphinxVerbatim}


\subsection{L’indexation d’une base de données avec Kraken 2}
\label{\detokenize{tutorial:l-indexation-d-une-base-de-donnees-avec-kraken-2}}\label{\detokenize{tutorial:indexation-kraken2}}
Le logiciel Kraken 2 propose :
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
l’indexation avec l’algorithme de k\sphinxhyphen{}mer d’une base de données,

\item {} 
la classification taxonomique des reads.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
L’étape d’indexation de la base de données est la plus coûteuse en ressources et en temps. Une fois construite, la base de données de Kraken 2 est conservée, et n’a besoin d’être reconstruite que si une mise à jour est nécessaire.
\end{sphinxadmonition}


\subsubsection{La théorie}
\label{\detokenize{tutorial:la-theorie}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{indexation_kraken_2}.png}}

Schéma des étapes d’indexation d’une base de données avec le logiciel Kraken 2 (image par Zygnematophyce).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Une base de données est une librairie de génomes (étape 1) qui recense l’ensemble des séquences génomiques.

\item {} 
Pour indexer la base de données sélectionnée, l’algorithme de Kraken 2 va ensuite hacher (étape 2) chaque génome de la base de données en fragments appelés k\sphinxhyphen{}mers de 31 nucléotides.

\item {} 
Chaque k\sphinxhyphen{}mer est ajouté à la base de données et obtient un numéro d’identification taxonomique (étape 3). Si c’est un nouveau k\sphinxhyphen{}mer, l’identifiant taxonomique de l’espèce d‘où il provient lui est associé.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
Si le k\sphinxhyphen{}mer est déjà présent dans la base de données, l’ancêtre commun le plus proche (LCA) des deux identifiants taxonomiques est utilisé pour identifier ce fragment.
\end{sphinxadmonition}


\sphinxstrong{Voir aussi:}


Les informations sur les taxons sont obtenues à partir de la base de données taxonomique du NCBI.




\subsubsection{La pratique}
\label{\detokenize{tutorial:la-pratique}}
La session qui suit, nous montre comment indexer la base de données avec l’algorithme de k\sphinxhyphen{}mer et l’outil Kraken 2.


\subsubsection{Programme}
\label{\detokenize{tutorial:id19}}
Nom du programme:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{create\PYGZus{}kraken\PYGZus{}database}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}


\subsubsection{Localisation}
\label{\detokenize{tutorial:id20}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
└── src
 ├── bash
 │   ├── create\PYGZus{}kraken\PYGZus{}database.sh
\end{sphinxVerbatim}


\subsubsection{Exemple d’utilisation}
\label{\detokenize{tutorial:id21}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash src/bash/create\PYGZus{}kraken\PYGZus{}database.sh \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}path\PYGZus{}seq data/raw\PYGZus{}sequences/fda\PYGZus{}argos\PYGZus{}raw\PYGZus{}genomes\PYGZus{}assembly\PYGZus{}06\PYGZus{}06\PYGZus{}2020/ \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}path\PYGZus{}db data/databases/kraken\PYGZus{}2/fda\PYGZus{}argos\PYGZus{}with\PYGZus{}none\PYGZus{}library\PYGZus{}kraken\PYGZus{}database\PYGZus{}07\PYGZus{}06\PYGZus{}2020/ \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}type\PYGZus{}db none \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}threads \PYG{l+m}{30}
\end{sphinxVerbatim}

Dans cet exemple, nous créons une base de données indexée à partir d’une librairie de séquence. Ici, les séquences assemblées de la base de données FDA\sphinxhyphen{}ARGOS qui se trouvent dans data/raw\_sequences/fda\_argos\_raw\_genomes\_assembly\_06\_06\_2020/ est la librairie choisie (voir {\hyperref[\detokenize{tutorial:download-fda-argos}]{\sphinxcrossref{\DUrole{std,std-ref}{Le téléchargement de la base de données FDA\sphinxhyphen{}ARGOS}}}}). Ensuite, avec le paramètre \sphinxhyphen{}path\_db nous précisons le chemin de sortie pour notre base de données indexée ici le chemin sera data/databases/kraken\_2/fda\_argos\_with\_none\_library\_kraken\_database\_07\_06\_2020/.

Le paramètres \sphinxhyphen{}type\_db est le paramètre qui détermine le type de la base de données. Nous avons choisi de ne pas rajouter d’autre libraire à notre base de données notre type est donc « none ».

\begin{sphinxadmonition}{note}{Note:}
Kraken 2 propose une multitude de librairies qui peuvent être rajoutées à notre base de données. La liste non exhaustive des possibilités :
\begin{itemize}
\item {} 
none : Paramètre qui empêche le téléchargement et l’installation d’une ou plusieurs bibliothèques de référence

\item {} 
bacteria : RefSeq génomes / protéines bactériens complets

\item {} 
viral : RefSeq génome / protéines virales complètes

\item {} 
human : génome / protéines humains GRCh38

\item {} 
fungi : RefSeq génomes / protéines fongiques complets

\item {} 
…

\end{itemize}
\end{sphinxadmonition}


\sphinxstrong{Voir aussi:}


Pour voir l’ensemble de la liste : \sphinxurl{https://github.com/DerrickWood/kraken2/wiki/Manual\#custom-databases}



Et enfin le nombre de threads pour accélérer le processus, ici le nombre de threads est à 30.


\subsubsection{Les paramètres}
\label{\detokenize{tutorial:id22}}\begin{quote}\begin{description}
\item[{\sphinxhyphen{}path\_seq}] \leavevmode
(Input) Chemin du dossier de la librairie de séquences sous format fna ou fasta.

\item[{\sphinxhyphen{}path\_db}] \leavevmode
(Output) Chemin du dossier de sortie pour créer et indexer notre base de données.

\item[{\sphinxhyphen{}type\_db}] \leavevmode
(Input) Quel type de librairie ajouter à notre base de données (choix : none, viral, fungi …).

\item[{\sphinxhyphen{}threads}] \leavevmode
(Input) Le nombre de threads pour indexer la base de données plus rapidement.

\item[{\sphinxhyphen{}taxonomy}] \leavevmode
(Optional) Dossier contenant la taxonomie du NCBI téléchargée par Kraken 2.

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
Dans le cas où l’on a téléchargé la taxonomie du NCBI en dehors de Kraken 2, on peut préciser le paramètre \sphinxhyphen{}taxonomy. Par défaut, le script va télécharger la taxonomie du NCBI automatiquement si le paramètre n’est pas précisé.
\end{sphinxadmonition}


\subsubsection{Les fichiers de sorties}
\label{\detokenize{tutorial:id23}}
Les fichiers de sorties sont les suivants :
\begin{itemize}
\item {} 
\sphinxstylestrong{hash.k2d} : Les mappages de taxons.

\item {} 
\sphinxstylestrong{opts.k2d} : Les options utilisées pour créer la base de données.

\item {} 
\sphinxstylestrong{taxo.k2d} : Les informations taxonomique utilisées pour créer la base de données.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Par défaut, le script supprime les fichiers intermédaires.
\end{sphinxadmonition}


\subsection{Classification des reads avec Kraken 2}
\label{\detokenize{tutorial:classification-des-reads-avec-kraken-2}}\label{\detokenize{tutorial:classification-kraken2}}
La session suivante, nous montre comment classifier un échantillon de reads avec le logiciel Kraken 2.

\begin{sphinxadmonition}{warning}{Avertissement:}
La classification des reads ne peut se faire sans une base de données de référence indexée par le logiciel Kraken 2 (voir {\hyperref[\detokenize{tutorial:indexation-kraken2}]{\sphinxcrossref{\DUrole{std,std-ref}{L’indexation d’une base de données avec Kraken 2}}}}).
\end{sphinxadmonition}


\subsubsection{La théorie}
\label{\detokenize{tutorial:id24}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=450\sphinxpxdimen]{{classification_kraken2}.png}}

Schéma des étapes de l’identification taxonomique d’une séquence cible avec le logiciel Kraken 2 (image par Zygnematophyce).

Pour classer une séquence, la séquence cible est fragmentée en tous les k\sphinxhyphen{}mers possibles de 31 nucléotides (étape 1). Chaque k\sphinxhyphen{}mer de la séquence cible est confronté à une base de données indexée par Kraken 2 (voir {\hyperref[\detokenize{tutorial:indexation-kraken2}]{\sphinxcrossref{\DUrole{std,std-ref}{L’indexation d’une base de données avec Kraken 2}}}}) par correspondance exacte de k\sphinxhyphen{}mers, et un identifiant taxonomique lui est assigné (étape 2).

Avec la liste complète des identifiants taxonomiques associés à un read, l’algorithme reproduit un arbre taxonomique où chaque nœud correspond à un identifiant taxonomique (étape 3). Dans l’arbre de classification, le nombre de k\sphinxhyphen{}mers mappés est comptabilisé et permet d’apporter du poids au nombre de k\sphinxhyphen{}mers dans la séquence associée au taxon du nœud de l’arbre (étape 4). La branche avec la somme la plus grande est choisie, et la feuille de cette branche (exemple le nœud à l’extrémité) est utilisée pour identifier le read.


\subsubsection{La pratique}
\label{\detokenize{tutorial:id25}}
La session qui suit, nous montre comment classifier des reads avec Kraken 2.


\subsubsection{Programme}
\label{\detokenize{tutorial:id26}}
Nom du programme:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{classify\PYGZus{}set\PYGZus{}reads\PYGZus{}kraken}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}


\subsubsection{Localisation}
\label{\detokenize{tutorial:id27}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
└── src
 ├── bash
 │   ├── classify\PYGZus{}set\PYGZus{}reads\PYGZus{}kraken.sh
\end{sphinxVerbatim}


\subsubsection{Exemple d’utilisation}
\label{\detokenize{tutorial:id28}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash src/bash/classify\PYGZus{}set\PYGZus{}reads\PYGZus{}kraken.sh \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}path\PYGZus{}reads results/trimmed\PYGZus{}reads/trimmed\PYGZus{}PAIRED\PYGZus{}SAMPLES\PYGZus{}ADN\PYGZus{}TEST\PYGZus{}reads\PYGZus{}01\PYGZus{}07\PYGZus{}2020/ \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}path\PYGZus{}db data/databases/kraken\PYGZus{}2/fda\PYGZus{}argos\PYGZus{}with\PYGZus{}none\PYGZus{}library\PYGZus{}kraken\PYGZus{}database\PYGZus{}07\PYGZus{}06\PYGZus{}2020/ \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}path\PYGZus{}output results/classify\PYGZus{}reads/trimmed\PYGZus{}classify\PYGZus{}fda\PYGZus{}argos\PYGZus{}with\PYGZus{}none\PYGZus{}library\PYGZus{}02\PYGZus{}07\PYGZus{}2020/ \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}threads \PYG{l+m}{27}
\end{sphinxVerbatim}

Dans cet exemple, nous allons classifier les reads traités dans le contenus dans le dossier results/trimmed\_reads/trimmed\_PAIRED\_SAMPLES\_ADN\_TEST\_reads\_01\_07\_2020/ .

\begin{sphinxadmonition}{note}{Note:}
Une étape de pré\sphinxhyphen{}traitement (pre\sphinxhyphen{}processing) est appliqué sur les reads en amont de cette étape de classification voir {\hyperref[\detokenize{tutorial:pre-processing}]{\sphinxcrossref{\DUrole{std,std-ref}{Le pré\sphinxhyphen{}traitement des reads}}}}.
\end{sphinxadmonition}

Nous indiquons quelle base de données de référence utiliser avec le paramètre \sphinxhyphen{}path\_db qui se trouve être dans le dossier data/databases/kraken\_2/fda\_argos\_with\_none\_library\_kraken\_database\_07\_06\_2020/ .

\begin{sphinxadmonition}{note}{Note:}
L’indexation d’une base de données de référence est expliqué dans la session {\hyperref[\detokenize{tutorial:indexation-kraken2}]{\sphinxcrossref{\DUrole{std,std-ref}{L’indexation d’une base de données avec Kraken 2}}}}
\end{sphinxadmonition}

Nous précisons le dossier de sortie dans lequel les résultats de classification pourront être déposés, ici nous choisissons results/classify\_reads/trimmed\_classify\_fda\_argos\_with\_none\_library\_02\_07\_2020/ .

Et enfin le nombre de threads pour accélérer le processus, ici le nombre de threads est à 27.


\subsubsection{Les paramètres}
\label{\detokenize{tutorial:id29}}\begin{quote}\begin{description}
\item[{\sphinxhyphen{}path\_reads}] \leavevmode
(Input) Le chemin du dossier contenant les reads.

\item[{\sphinxhyphen{}path\_db}] \leavevmode
(Input) Le chemin du dossier qui contient la base de donnée indexé par Kraken 2.

\item[{\sphinxhyphen{}path\_output}] \leavevmode
(Output) Le nom du dossier pour les sorties.

\item[{\sphinxhyphen{}threads}] \leavevmode
(Input) Le nombre de threads utilisé pour classifier les reads. Par défaut le nombre de threads est 8.

\end{description}\end{quote}


\subsubsection{Les fichiers de sorties}
\label{\detokenize{tutorial:id30}}
Les fichiers de sorties sont les suivants :
\begin{itemize}
\item {} 
\sphinxstylestrong{.clseqs.fastq} : Les séquences classifiées.

\item {} 
\sphinxstylestrong{.unclseqs.fastq} : Les séquences non\sphinxhyphen{}classifiées.

\item {} 
\sphinxstylestrong{.report.txt} : Format de rapport standard de Kraken 2 avec une ligne par taxon (délimité par des tabulations).

\item {} 
\sphinxstylestrong{.output.txt} : Format de sortie standard de Kraken 2. Chaque séquence classée par Kraken 2 entraîne une seule ligne de sortie. Les lignes de sortie de Kraken 2 contiennent cinq champs séparés par des tabulations.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Pour comprendre en détail comment est agencé le fichier de sortie \sphinxstyleemphasis{.output.txt} voir la documentation officielle : \sphinxurl{https://github.com/DerrickWood/kraken2/wiki/Manual\#output-formats} .
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Pour comprendre en détail la composition du fichier de sortie \sphinxstyleemphasis{.report.txt} voir la documentation officielle : \sphinxurl{https://github.com/DerrickWood/kraken2/wiki/Manual\#sample-report-output-format} .
\end{sphinxadmonition}


\subsection{Création d’une base de données avec la suite BLAST+}
\label{\detokenize{tutorial:creation-d-une-base-de-donnees-avec-la-suite-blast}}\label{\detokenize{tutorial:creation-database-blast}}
La session suivante, nous montre comment créer une base de données locale qui permettra d’utiliser en amont l’alignement de séquence par l’algorithme de BLAST.


\subsubsection{Dépendances}
\label{\detokenize{tutorial:id31}}
Avec la suite BLAST + nous utilisons :
\begin{itemize}
\item {} 
L’application \sphinxstylestrong{makeblastdb} qui produit une base de données locale adaptée à l’algorithme de BLAST.

\item {} 
L’application \sphinxstylestrong{dustmasker} qui identifie et masque les parties à faible complexité d’un génome.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Les séquences de faible complexité sont par exemple les séquences répétées « ACACACACACACACACACACACACACAC » connus pour se produire dans de nombreux organismes différents et moins instructifs dans les alignements. Enlever ces séquences aide à prévenir les faux positifs dans les résultats.
\end{sphinxadmonition}


\sphinxstrong{Voir aussi:}


Pour comprendre rapidement l’utilisation de chaque application voir \sphinxurl{https://www.ncbi.nlm.nih.gov/books/NBK279681/} .



\begin{sphinxadmonition}{warning}{Avertissement:}
Pour l’instant, aucune implementation a été faite au niveau de la création d’une base de données concernant les séquences proteiques ainsi que la suppression des séquences à faible complexité des proteines (par exemple avec le logiciel segmasker).
\end{sphinxadmonition}


\subsubsection{Programme}
\label{\detokenize{tutorial:id32}}
Nom du programme:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{create\PYGZus{}blast\PYGZus{}database}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}


\subsubsection{Localisation}
\label{\detokenize{tutorial:id33}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
└── src
 ├── bash
 │   ├── create\PYGZus{}blast\PYGZus{}database.sh
\end{sphinxVerbatim}


\subsubsection{Exemple d’utilisation}
\label{\detokenize{tutorial:id34}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash src/bash/create\PYGZus{}blast\PYGZus{}database.sh \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}path\PYGZus{}seq data/raw\PYGZus{}sequences/refseq/bacteria/ \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}output\PYGZus{}db data/databases/blast/refseq/
\end{sphinxVerbatim}

Dans cet exemple, nous créons une base de données adaptée à BLAST en indiquant les séquences que l’on veut ajouter à notre base de données. Ici les séquences à ajouter sont celles téléchargées avec la base de données RefSeq expliqué en détail dans la session {\hyperref[\detokenize{tutorial:download-refseq}]{\sphinxcrossref{\DUrole{std,std-ref}{Le téléchargement de la base de données RefSeq}}}} du tutoriel. Ensuite, avec le paramètre \sphinxhyphen{}output\_db nous précisons le chemin de sortie pour notre base de données.


\subsubsection{Les paramètres}
\label{\detokenize{tutorial:id35}}\begin{quote}\begin{description}
\item[{\sphinxhyphen{}path\_seq}] \leavevmode
(Input) Chemin du dossier de la librairie de séquences.

\item[{\sphinxhyphen{}output\_db}] \leavevmode
(Output) Chemin du dossier de sortie pour créer notre base de données.

\item[{\sphinxhyphen{}dustmasker}] \leavevmode
(Optional) Paramètre optionnel qui permet de choisir l’application ou non de dustmasker sur notre génome. Par défaut, le paramètre est sur « yes ». Pour ne pas utiliser dustmasker et changer le paramètre par « no » comme illustré ci\sphinxhyphen{}dessous.

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash src/bash/create\PYGZus{}blast\PYGZus{}database.sh \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}path\PYGZus{}seq data/raw\PYGZus{}sequences/refseq/bacteria/ \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}output\PYGZus{}db data/databases/blast/refseq/ \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}dustmasker no
\end{sphinxVerbatim}

Ici, nous créons un base de données refseq adapté à BLAST mais sans utiliser \sphinxstyleemphasis{dustmasker} et donc sans supprimer les séquences à faible complexité dans notre base de données.
\begin{quote}\begin{description}
\item[{\sphinxhyphen{}force\_remove}] \leavevmode
(Optional) Paramètre optionnel qui permet de ne pas supprimer les fichiers intermédiaires. Par défaut, le paramètre est sur « yes » et supprime les fichiers intermédiares. Pour ne pas supprimer les fichiers intermédiaires changer le param\_tre par « no » comme illustré ci\sphinxhyphen{}dessous.

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash src/bash/create\PYGZus{}blast\PYGZus{}database.sh \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}path\PYGZus{}seq data/raw\PYGZus{}sequences/refseq/bacteria/ \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}output\PYGZus{}db data/databases/blast/refseq/ \PYG{l+s+se}{\PYGZbs{}}
             \PYGZhy{}dustmasker no
             \PYGZhy{}force\PYGZus{}remove no
\end{sphinxVerbatim}

Ici, nous créons un base de données refseq adapté à BLAST mais sans utiliser \sphinxstyleemphasis{dustmasker} et sans supprimer les fichiers intermédiaires.


\subsubsection{Les fichiers de sorties}
\label{\detokenize{tutorial:id36}}
Les fichiers de sorties de la base de données sont par exemple :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
.
├── makeblastdb.naa
├── makeblastdb.nab
├── makeblastdb.nac
├── makeblastdb.nhr
├── makeblastdb.nin
├── makeblastdb.nog
├── makeblastdb.nsd
├── makeblastdb.nsi
├── makeblastdb.nsq
└── README.txt
\end{sphinxVerbatim}


\subsection{Classification des reads avec la suite BLAST+}
\label{\detokenize{tutorial:classification-des-reads-avec-la-suite-blast}}\label{\detokenize{tutorial:classification-blast}}

\section{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}